package tmtintegrator.integrator;

import tmtintegrator.pojo.ds_Index;
import tmtintegrator.pojo.ds_Parameters;
import tmtintegrator.pojo.PsmInfo;
import tmtintegrator.utils.Utils;

import java.util.*;

/**
 * Utility class to process PSMs.
 *
 * @author rogerli on 05/2024
 */

public class PsmProcessor {
    private final ds_Parameters parameters;
    private final Map<String, Map<String, PsmInfo>> groupPsmMap; // <groupKey(proteinId), <fileName, psmInfo>>
    public static final int PSM_NUM_THRESHOLD = 4; // threshold for outlier removal

    public PsmProcessor(ds_Parameters parameters) {
        this.parameters = parameters;
        this.groupPsmMap = new TreeMap<>();
    }

    public Map<String, Map<String, PsmInfo>> getGroupPsmMap() {
        return groupPsmMap;
    }

    /**
     * Group PSMs by protein ID into a map.
     *
     * @param fileMap map of file path to list of PSM entries
     */
    public void groupPsm(Map<String, List<String>> fileMap) {
        for (Map.Entry<String, List<String>> entry : fileMap.entrySet()) {
            String filePath = entry.getKey();
            List<String> psmList = entry.getValue();
            ds_Index index = parameters.indMap.get(filePath);

            for (String psm : psmList) {
                groupPsmEntry(filePath, psm, index);
            }
        }

        // compute the total reference intensity
        computeTotalRefInt();
    }

    /**
     * Remove outliers from PSMs.
     */
    public void removeOutlier() {
        for (Map.Entry<String, Map<String, PsmInfo>> groupEntry : groupPsmMap.entrySet()) {
            Map<String, PsmInfo> fileMap = groupEntry.getValue();
            for (Map.Entry<String, PsmInfo> entry : fileMap.entrySet()) {
                String filePath = entry.getKey();
                PsmInfo psmInfo = entry.getValue();
                ds_Index index = parameters.indMap.get(filePath);
                // Only process psmInfo with psmList over threshold for speed
                if (psmInfo.psmList.size() >= PSM_NUM_THRESHOLD) {
                    List<String> normPsmList = processPsmListByIQR(psmInfo.psmList, index);
                    psmInfo.psmList.clear();
                    psmInfo.psmList.addAll(normPsmList);
                }
            }
        }
    }

    public void collapse() {
        
    }

    // region helper methods
    private void groupPsmEntry(String filePath, String psm, ds_Index index) {
        String[] fields = psm.split("\t");
        String[] psmKeyParts = fields[0].split("#");
        String groupKey = psmKeyParts[0]; // generated by groupBy option while loading
        String newPepSequence = psmKeyParts[2];
        String extPepSequence = Utils.refineExtendedSequence(fields[index.extpepIndex]);
        String gene = fields[index.genecIndex];
        int pepsIndex = Integer.parseInt(fields[index.protsIndex]) - 1;

        // Ensure the group key exists, and create a new PSM info if necessary
        Map<String, PsmInfo> fileMap = groupPsmMap.computeIfAbsent(groupKey, k -> new TreeMap<>());
        PsmInfo psmInfo = fileMap.computeIfAbsent(filePath, k -> new PsmInfo());
        psmInfo.gene = gene;
        if (psmInfo.peptide.isEmpty()) {
            // for new PsmInfo, set peptide and pepsIndex
            psmInfo.peptide = newPepSequence;
            psmInfo.pepsIndex = pepsIndex;
        } else if (psmInfo.peptide.length() < newPepSequence.length()) {
            // update peptide and pepsIndex if new peptide is longer
            psmInfo.peptide = newPepSequence;
//            psmInfo.pepsIndex = pepsIndex; // FIXME: should be updated, but it will always be the first pepsIndex
            // FIXME: Here is the original code, where seems the intention is to update pepsIndex as well
            //   however, with the current implementation, it will always be the first pepsIndex
            //   psmInfo.peptide = (psmInfo.peptide.length() < newPepSequence.length()) ? newPepSequence : psmInfo.peptide;
            //   psmInfo.pepsIndex = (psmInfo.peptide.length() < newPepSequence.length()) ? pepsIndex: psmInfo.pepsIndex; // pepIndex will never be updated
            // FIXME END
        }
        psmInfo.extpep = extPepSequence;
        psmInfo.psmList.add(psm);
    }

    private void computeTotalRefInt() {
        for (Map.Entry<String, Map<String, PsmInfo>> groupEntry : groupPsmMap.entrySet()) {
            Map<String, PsmInfo> fileMap = groupEntry.getValue();
            for (PsmInfo psmInfo : fileMap.values()) {
                computePsmInfoTotalRefInt(psmInfo);
            }
        }
    }

    private void computePsmInfoTotalRefInt(PsmInfo psmInfo) {
        List<Double> refIntensityList = new ArrayList<>();
        for (String psm : psmInfo.psmList) {
            double refIntensity = extractRefIntensity(psm);
            refIntensityList.add(refIntensity);
            psmInfo.totalRefInt += refIntensity; // sum all peptide intensities
        }
        Collections.sort(refIntensityList);

        // compute top 3 intensive peptides TODO: why overwriting totalRefInt?
        if (parameters.top3Pep && psmInfo.psmList.size() >= 3) {
            psmInfo.totalRefInt = 0;
            for (int i = refIntensityList.size() - 1; i >= refIntensityList.size() - 3; i--) {
                psmInfo.totalRefInt += refIntensityList.get(i);
            }
        }
    }

    private double extractRefIntensity(String psm) {
        String[] fields = psm.split("\t");
        String[] psmKeyParts = fields[0].split("#");
        return Double.parseDouble(psmKeyParts[1]);
    }

    private List<String> processPsmListByIQR(List<String> psmList, ds_Index index) {
        double[][] ratio2DValues = Utils.convertTo2DArray(psmList, index);
        // remove outlier from each channel
        removeOutlierByChannel(ratio2DValues, index);
        return Utils.updatePsmRatios(psmList, ratio2DValues, index);
    }

    private void removeOutlierByChannel(double[][] ratio2DValues, ds_Index index) {
        for (int j = 0; j < index.plexNum; j++) {
            List<Double> ratios = new ArrayList<>();
            for (double[] row : ratio2DValues) {
                if (row[j] != -9999) { // FIXME: !Double.isNaN(row[j]) is better
                    ratios.add(row[j]);
                }
            }

            // calculate IQR for outlier removal
            if (ratios.size() >= PSM_NUM_THRESHOLD) {
                double[] iqrBounds = Utils.computeIQR(ratios); // lower and upper bounds
                for (double[] row : ratio2DValues) {
                    // remove outliers
                    if (!Double.isNaN(row[j]) && (row[j] < iqrBounds[0] || row[j] > iqrBounds[1])) {
                        row[j] = -9999; // FIXME: Double.NaN is better
                    }
                }
            }
        }
    }
    // endregion
}
